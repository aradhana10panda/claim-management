package com.claimmanagement.mapper;

import com.claimmanagement.model.dto.ClaimRequestDto;
import com.claimmanagement.model.dto.ClaimResponseDto;
import com.claimmanagement.model.entity.Claim;
import org.mapstruct.*;

import java.util.List;

/**
 * MapStruct Mapper Interface for Claim Entity and DTOs
 * <p>
 * MapStruct is a compile-time code generator that creates mapping implementations
 * <p>
 * Benefits of MapStruct:
 * 1. Performance: Generates plain Java code (no reflection)
 * 2. Type Safety: Compile-time checking of mappings
 * 3. IDE Support: Auto-completion and refactoring support
 * 4. Maintainability: Clear mapping definitions
 * 5. Debugging: Generated code is readable and debuggable
 * <p>
 * How MapStruct Works:
 * 1. Annotation processor runs during compilation
 * 2. Generates implementation class (ClaimMapperImpl)
 * 3. Spring finds and injects the generated implementation
 * 4. Mappings are based on matching property names
 * 5. Custom mappings can be defined with @Mapping annotations
 *
 * @author Claim Management Team
 * @Mapper Annotation Parameters:
 * - componentModel = "spring": Generates Spring component (@Component)
 * - unmappedTargetPolicy = ReportingPolicy.IGNORE: Ignores unmapped target properties
 * - nullValuePropertyMappingStrategy: How to handle null values
 */
@Mapper(
        componentModel = "spring",                                    // Generate Spring component
        unmappedTargetPolicy = ReportingPolicy.IGNORE,              // Ignore unmapped properties
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE  // Ignore null values
)
public interface ClaimMapper {

    /**
     * Maps ClaimRequestDto to Claim entity for creation
     *
     * @param requestDto The request DTO containing claim data
     * @return New Claim entity (without system-generated fields)
     * @Mapping annotations specify custom mapping rules:
     * - target: Property name in target object (Claim)
     * - ignore = true: Skip mapping this property
     * <p>
     * Ignored properties for creation:
     * - id: Auto-generated by database
     * - claimNumber: Generated by service layer
     * - createdAt: Set by @CreationTimestamp
     * - updatedAt: Set by @UpdateTimestamp
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "claimNumber", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    Claim toEntity(ClaimRequestDto requestDto);

    /**
     * Maps Claim entity to ClaimResponseDto
     * <p>
     * All properties are mapped automatically based on matching names
     * No custom mappings needed as all entity properties should be included in response
     *
     * @param claim The claim entity from database
     * @return Response DTO with all claim information
     */
    @Named("toResponseDto")
    ClaimResponseDto toResponseDto(Claim claim);

    /**
     * Maps list of Claim entities to list of ClaimResponseDtos
     * <p>
     * MapStruct automatically generates this method based on the single entity mapping
     * Very useful for returning multiple claims (search results, etc.)
     *
     * @param claims List of claim entities
     * @return List of response DTOs
     */
    @IterableMapping(qualifiedByName = "toResponseDto")
    List<ClaimResponseDto> toResponseDtoList(List<Claim> claims);

    /**
     * Updates existing Claim entity with data from ClaimRequestDto
     *
     * @param requestDto The request DTO with updated data
     * @param claim      The existing claim entity to update
     * @MappingTarget annotation indicates the target object to update
     * This is useful for PATCH/PUT operations where you want to update existing entity
     * <p>
     * Ignored properties for updates:
     * - id: Should never change
     * - claimNumber: Business key, should not change
     * - createdAt: Historical data, should not change
     * - updatedAt: Automatically updated by @UpdateTimestamp
     * <p>
     * Null value strategy ensures null values in DTO don't overwrite existing entity values
     * This enables partial updates (PATCH semantics)
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "claimNumber", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    void updateEntityFromDto(ClaimRequestDto requestDto, @MappingTarget Claim claim);

    /**
     * Custom mapping method for status updates only
     * <p>
     * Sometimes you need to update only specific fields
     * This method demonstrates how to create specialized mapping methods
     *
     * @param claim The claim entity to convert
     * @return Response DTO with minimal information for status updates
     */
    @Named("toStatusResponseDto")
    @Mapping(target = "claimantPhone", ignore = true)
    @Mapping(target = "description", ignore = true)
    ClaimResponseDto toStatusResponseDto(Claim claim);

    /**
     * After-mapping method to perform custom logic after automatic mapping
     *
     * @param requestDto Source DTO
     * @param claim      Target entity
     * @AfterMapping annotation indicates this method runs after the main mapping
     * Useful for:
     * - Complex calculations
     * - Setting derived properties
     * - Validation
     * - Logging
     * <p>
     * Example: Set default status if not provided in request
     */
    @AfterMapping
    default void setDefaultValues(ClaimRequestDto requestDto, @MappingTarget Claim claim) {
        // Set default status to SUBMITTED if not provided
        if (claim.getStatus() == null) {
            claim.setStatus(com.claimmanagement.model.entity.ClaimStatus.SUBMITTED);
        }
    }

    /**
     * Before-mapping method to perform validation or preprocessing
     *
     * @param requestDto Source DTO to validate
     * @BeforeMapping annotation indicates this method runs before the main mapping
     * Useful for:
     * - Input validation
     * - Data preprocessing
     * - Logging
     */
    @BeforeMapping
    default void validateRequest(ClaimRequestDto requestDto) {
        // Custom validation logic can be added here
        // For example, business rule validations that go beyond bean validation
        if (requestDto != null && requestDto.getClaimAmount() != null) {
            // Log high-value claims for additional review
            if (requestDto.getClaimAmount().compareTo(java.math.BigDecimal.valueOf(100000)) > 0) {
                System.out.println("High-value claim detected: " + requestDto.getClaimAmount());
            }
        }
    }
}